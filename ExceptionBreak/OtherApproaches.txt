var apartmentLoaderClsid = Guid.Parse("{CA554A15-4410-45C9-B5C1-20DE052D9CD3}");
var apartmentLoaderType = Type.GetTypeFromCLSID(apartmentLoaderClsid, true);

IDebugEngine2 debugEngine;
try {
    var apartmentLoader = (IVsLoader)Activator.CreateInstance(apartmentLoaderType);

    var engineClsid = Guid.Parse("{7386310B-D5CB-4369-9BDD-609B3F103914}");
    //var engineType = Type.GetTypeFromCLSID(engineGuid, true);

    object debugEngineUnknown;
    var r = apartmentLoader.Load(
        @"p:\Microsoft Visual Studio 2010\Common7\Packages\Debugger\cpde.dll",
        ref engineClsid,
        IntPtr.Zero,
        (uint)0x23, // CLSCTX_ALL
        out debugEngineUnknown);

    if (r != 0)
        Marshal.ThrowExceptionForHR(r);

    debugEngine = (IDebugEngine2)debugEngineUnknown;
}
catch (Exception ex) {
    logger.WriteLine("Exception " + ex);
    return;
}

logger.WriteLine("We got an IDebugEngine2? " + debugEngine + "!");
var engineGuid = Guid.Parse("{449EC4CC-30D2-4032-9256-EE18EB41B62B}");
var hr = debugEngine.SetException(new[] {
    new EXCEPTION_INFO {
        guidType = engineGuid,
        bstrExceptionName = "System.ArgumentException",
        dwState = 0x00FF // EXCEPTION_STOP_ALL
    }
});
if (hr != 0)
    Marshal.ThrowExceptionForHR(hr);

this.hookPtr = Native.SetWindowsHookEx(Native.HookType.WH_CALLWNDPROCRET, this.callback, IntPtr.Zero, Native.GetCurrentThreadId());
this.dte.ExecuteCommand("Debug.Exceptions");


IntPtr dialogHandle;
using (var hook = new NextShowWindowHook()) {
    this.dte.ExecuteCommand("Debug.Exceptions");
    dialogHandle = hook.CapturedHandle;
}

var tree = Native.FindWindowEx(dialogHandle, IntPtr.Zero, "SysTreeView32", null);

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace BreakOnExceptionsPlus.Interop {
    [ComImport]
    [Guid("10E4254C-6D73-4C38-B011-E0049B2E0A0F")]
    [InterfaceType(ComInterfaceType.InterfaceIsDual)] 
    public interface IVsLoader {
        [PreserveSig]
        int Load([In, MarshalAs(UnmanagedType.BStr)] string strModule,
                 ref Guid rclsid,
                 IntPtr unkOuter,
                 uint dwClsContext,
                 [Out, MarshalAs(UnmanagedType.IUnknown)] out object ppunk);
    }
}

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;

namespace BreakOnExceptionsPlus.Interop {
    public static class Native {
        public enum WindowMessage {
            WM_SHOWWINDOW = 0x18
        }

        public enum HookType {
            WH_JOURNALRECORD = 0,
            WH_JOURNALPLAYBACK = 1,
            WH_KEYBOARD = 2,
            WH_GETMESSAGE = 3,
            WH_CALLWNDPROC = 4,
            WH_CBT = 5,
            WH_SYSMSGFILTER = 6,
            WH_MOUSE = 7,
            WH_HARDWARE = 8,
            WH_DEBUG = 9,
            WH_SHELL = 10,
            WH_FOREGROUNDIDLE = 11,
            WH_CALLWNDPROCRET = 12,
            WH_KEYBOARD_LL = 13,
            WH_MOUSE_LL = 14
        }

        public enum GetWindowCmd {
            GW_HWNDFIRST = 0,
            GW_HWNDLAST = 1,
            GW_HWNDNEXT = 2,
            GW_HWNDPREV = 3,
            GW_OWNER = 4,
            GW_CHILD = 5,
            GW_ENABLEDPOPUP = 6
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CWPRETSTRUCT {
            public IntPtr lResult;
            public IntPtr lParam;
            public IntPtr wParam;
            public uint message;
            public IntPtr hWnd;
        }

        public delegate IntPtr HookProc(int code, IntPtr wParam, IntPtr lParam);

        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr SetWindowsHookEx(HookType hookType, HookProc lpfn, IntPtr hMod, uint dwThreadId);

        [DllImport("user32.dll", SetLastError = true)]
        public static extern int UnhookWindowsHookEx(IntPtr hhk);

        [DllImport("user32.dll")]
        public static extern IntPtr CallNextHookEx(IntPtr hhk, int nCode, IntPtr wParam, IntPtr lParam);

        [DllImport("kernel32.dll")]
        public static extern uint GetCurrentThreadId();

        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr GetWindow(IntPtr hWnd, GetWindowCmd uCmd);

        [DllImport("user32.dll", SetLastError = true)]
        public static extern IntPtr FindWindowEx(IntPtr hwndParent, IntPtr hwndChildAfter, string lpszClass, string lpszWindow);
    }
}

public int Event(IDebugEngine2 pEngine, IDebugProcess2 pProcess, IDebugProgram2 pProgram, IDebugThread2 pThread, IDebugEvent2 pEvent, ref Guid riidEvent, uint dwAttrib) {
    this.logger.WriteLine("Debug event: pEngine = {0}, pProcess = {1}, pProgram = {2}, pThread = {3}, pEvent = {4}, riidEvent = {5}, dwAttrib = {6}",
                            pEngine, pProcess, pProgram, pThread, pEvent, riidEvent, dwAttrib);

    if (riidEvent != typeof(IDebugSessionCreateEvent2).GUID)
        return VSConstants.S_OK;

    var sessionEvent = (IDebugSessionEvent2)pEvent;
    IDebugSession2 session;
    sessionEvent.GetSession(out session);

    this.DebugSession = session;
    this.DebugSessionChanged(this, EventArgs.Empty);

    return VSConstants.S_OK;
}


this.debugEventCallback = new DebugSessionWatcher(this.logger);
this.debugger.AdviseDebugEventCallback(this.debugEventCallback);


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using BreakOnExceptionsPlus.Interop;

namespace BreakOnExceptionsPlus.Implementation {
    public class NextShowWindowHook : IDisposable {
        private readonly Native.HookProc callback;
        private IntPtr hookPtr;

        public NextShowWindowHook() {
            this.callback = this.WndProcCallback;
            this.hookPtr = Native.SetWindowsHookEx(Native.HookType.WH_CALLWNDPROCRET, this.callback, IntPtr.Zero, Native.GetCurrentThreadId());
        }

        public IntPtr CapturedHandle { get; private set; }
        
        private IntPtr WndProcCallback(int code, IntPtr wParam, IntPtr lParam) {
            if (code < 0)
                return Native.CallNextHookEx(this.hookPtr, code, wParam, lParam);

            var msg = (Native.CWPRETSTRUCT)Marshal.PtrToStructure(lParam, typeof(Native.CWPRETSTRUCT));
            if (msg.message == (uint)Native.WindowMessage.WM_SHOWWINDOW) {
                CapturedHandle = msg.hWnd;
                Native.UnhookWindowsHookEx(this.hookPtr);
                this.hookPtr = IntPtr.Zero;

                //return IntPtr.Zero;
            }

            return Native.CallNextHookEx(this.hookPtr, code, wParam, lParam);
        }
        
        public void Dispose() {
            this.Dispose(true);
        }

        private void Dispose(bool disposing) {
            if (this.hookPtr != IntPtr.Zero)
                Native.UnhookWindowsHookEx(this.hookPtr);

            if (disposing)
                GC.SuppressFinalize(this);
        }

        ~NextShowWindowHook() {
            this.Dispose(false);
        }
    }
}
